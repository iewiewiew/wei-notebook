[TOC]

<h1 align="center">MQ</h1>

> By：weimenghua  
> Date：2022.10.2  
> Description：MQ 消息队列

**参考资料**  
[9个问答牢记RocketMQ架构](https://mp.weixin.qq.com/s/L9lYIp3AMaXc6CRgVmsPEw)



## 消息队列

### 1、使用场景

错峰控制：秒杀业务用于流量削峰
解耦（本质）
最终一致性：两个系统的状态保持一致，要么都成功，要么都失败
广播：只需要关心消息是否送达了队列，至于谁希望订阅，是下游的事情，无疑极大地减少了开发和联调的工作量

### 2、常见消息队列
Kafka、RocketMQ、RabbitMQ、ActiveMQ

### 3、broker
代码在运行的时候需要先运行一下消费者，相当于你订阅了这个 topic（类似于关注了一个微信公众号），不然接收不到消息。
消息主题 topic：消息的识别属性，一般同类消息具有相同的 topic，比如商品中心发出的消息为 itemcenter。一个 Topic(消息主题)可能对应多个实际的消息队列(MessgeQueue)。
Broker 是 RocketMQ 的核心，大部分重量级工作都是由 Broker 完成的，包括接收 Producer 发过来的消息、处理 Consumer 的消费消息请求、消息的持久化存储、消息的 HA 机制以及服务端过滤功能等。

### 4、RPC
1）消息的转储：在更合适的时间点投递，或者通过一系列手段辅助消息最终能送达消费机。
2）规范一种范式和通用的模式，以满足解耦、最终一致性、错峰等需求。
3）其实简单理解就是一个消息转发器，把一次 RPC 做成两次 RPC，发送者把消息投递到 broker，broker 再将消息转发一手到接收端。

总结起来就是两次 RPC 加一次转储，如果要做消费确认，则是三次 RPC。
为了实现上述消息队列的基础功能：
消息的传输
存储
消费

就需要涉及到如下三个方面的设计：
通信协议
存储选择
消费关系维护

### 5、组件说明
服务 broker：消息服务端，包括消息路由、存储，基于 zk 进行分布式服务协调，是消息生产者和消费者之间的中间人
发布者 producer：消息的生产端，按一定主题发送到 broker
消费者 consumer：消息的消费端，分主动 pull 和被动 push 两种模式
分区 partition：消息主题的数据分片，单个 broker 服务器可以包括多个 topic 消息的 partition 数据，同一 topic 的不同 partition 也可以跨多个 broker 存在  
消费组 group：多个消费者组成一个消费组共同消费同一 topic 消息，消息被组中任意消费者消费成功即认为消费成功  
消费偏移 offset：对于消费者而言，消费偏移量纪录了当前已消费的位置信息，是相对于 partition 文件的逻辑偏移量，会持久化保存以便失败恢复  
消息协商器（Message Broker）,在一个连接中，客户端声明了一个通道，通过单一连接到协商器的并发控制需要建立一个可靠的模型，这里可以使用通道池和串行访问或者例如线程本地通道这样的线程并发模型。  